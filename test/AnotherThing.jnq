

type AnotherThing struct {
  x float, 
  y float,
  z float, 
}


type FILE enum { 
  X, Y, Z 
}

type Function struct { 
}


fn c_fn(f *FILE, fn *Function) {
  if (!fn)
    return

  c_fn(f, fn->next)

  c_type_declare(f, fn->returnType)
  fprintf(f, " %s(", fn->name);
  c_var_list(f, fn->parameter, ", ")
  if (!fn->body)
    fprintf(f, ") {}\n\n")
  else {
    fprintf(f, ") {\n")
    c_statements(f, fn->body, 2)
    fprintf(f, "}\n\n")
  }
}


type Module struct {}
type Program struct {}
type TypeKind struct {}
type Type struct {}

fn add_type(p *Program, k TypeKind, name *char, m *Module) *Type {
  tt *Type = p->alloc(sizeof(Type)) as *Type
  tt->name = name;
  tt->kind = k;

  switch (k) {
  case Klass:
    tt->member = NULL
  case Enum:
    tt->entries = NULL
  case Union:
  default:
  }
  
  tt->next = m->types;
  m->types = tt;
  return tt;
}