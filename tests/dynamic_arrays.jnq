
use printf from C.stdio
use qsort from C.stdlib

type ABC struct {
  a i32,
  b f32,
  c char,
}

fn check_all_doubled_c(a *i32, l i32){
  for (i := 0; i < l; ++i)
    ASSERT(a[i] == i * 2)
}

fn check_all_doubled(a[*]i32){
  for (i := 0; i < len(a) ; ++i)
    ASSERT(a[i] == i * 2)
}

fn simple_int()
{
  printf(" .simple_int\n")
  a := new[32]i32{}
  for (i := 0; i < 32; ++i)
    a[i] = i * 2

  ASSERT(32u == len_s(a))
  ASSERT(32u == cap_s(a))
  ASSERT(32 == len(a))
  ASSERT(32 == cap(a))
  for (i := 0; i < len(a); ++i)
    ASSERT(a[i] == i * 2)
  check_all_doubled_c(a, len(a) )
  check_all_doubled(a)

  a = resize(a, 64)
  ASSERT(64 == len(a))
  ASSERT(64 == cap(a))

  a = reserve(a, 42)
  ASSERT(64 == len(a))
  ASSERT(64 == cap(a))

  a = push(a, 54321)
  ASSERT(65 == len(a))
  ASSERT(65 <= cap(a))
  ASSERT(8000 > cap(a))

  a = reserve(a, 8000)
  ASSERT(65 == len(a))
  ASSERT(8000 == cap(a))

  val := pop(a)
  print("len", len(a), "cap", cap(a))
  ASSERT(len(a) == 64)
  ASSERT(8000 == cap(a))
  ASSERT(val == 54321)

  delete a

  a = null
  ASSERT(0 == len(a))
  ASSERT(0 == cap(a))
}

fn simple_struct()
{
  printf(" .simple_struct\n")

  b := new[3]ABC{}
  ASSERT(len(b) == 3)
  ASSERT(cap(b) == 3)
  for (i := 0; i < len(b); ++i) {
    b[i].a = i * 3
    b[i].b = i as f32 / 2.0f
    b[i].c = (i) as char + 'a'
  }
  for (i := 0; i < len(b) ; ++i) {
    ASSERT(b[i].a == i * 3)
    ASSERT(b[i].b == i as f32 / 2.0f)
    ASSERT(b[i].c == i as char + 'a')
  }

  delete b
}

type XYZ struct {
  a[*]f32,
}

fn as_members()
{
  printf(" .as_members\n")

  w := XYZ{null}
  ASSERT(len(w.a) == 0)
  ASSERT(cap(w.a) == 0)

  w.a = new[8]f32{}

  ASSERT(len(w.a) == 8)
  ASSERT(cap(w.a) == 8)

  for (i := 0; i < len(w.a) ; ++i)
    w.a[i] = i as f32 * 10.0f

  for (i := 0; i < len(w.a) ; ++i)
    ASSERT(w.a[i] == i as f32 * 10.0f)
}

fn comp(const ap any, const bp any) i32 {
  a := *(ap as *i32)
  b := *(bp as *i32)
  if (a < b) return -1
  if (a > b) return 1
  return 0
}

fn qsort_any_dynamic_array()
{
  printf(" .qsort_any_dynamic_array\n")

  a := new[]i32{}
  for (i := 0; i < 10; ++i)
    push(a, 100 - i *2)

  for (i := 1; i < len(a) ; ++i)
    ASSERT(a[i -1] > a[i])
  qsort(a, len_s(a), sizeof(i32), comp)
  for (i := 1; i < len(a) ; ++i)
    ASSERT(a[i -1] < a[i])

  delete a
}

type SomeAble interface {
  fn id(s *SomeAble) i32
}

type SomeImp struct {
  val i32
}

fn id(s *SomeImp) i32 {
  return s.val
}

fn interface_in_dynamic_array()
{
  printf(" .interface_in_dynamic_array\n")

  a := new[]SomeAble{}

  x := SomeImp{42}

  push(a, null)
  push(a, &x)

  ASSERT(a[0] == null)
  ASSERT(a[1] != null)
  ASSERT(a[1].id() == 42)

  delete a
}

fn create_an_array(l i32) [*]i32 {
  return reserve(new[]i32{}, l)
}

fn dynamic_array_as_return_value()
{
  printf(" .dynamic_array_as_return_value\n")

  a := create_an_array(42)
  ASSERT(len(a) == 0)
  ASSERT(cap(a) == 42)

  delete a
}

fn dynamic_array_null_test() {
  print("..dynamic_array_null_test\n")

  dyn_null := null as[*]i32

  ASSERT(dyn_null == null)
  ASSERT(null == dyn_null)
  ASSERT(!(dyn_null != null))
  ASSERT(!(null != dyn_null))

  ASSERT(!dyn_null)

  dyn_null = new[]i32{}
  ASSERT(dyn_null)
  delete dyn_null
}

fn main() i32 {
  printf("dynamic arrays\n")

  simple_int()
  simple_struct()
  as_members()
  qsort_any_dynamic_array()
  interface_in_dynamic_array()
  dynamic_array_as_return_value()
  dynamic_array_null_test()

  printf(" ...ok\n")
  return 0
}