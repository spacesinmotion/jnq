
use Module

cfn strncpy(d *char, s *char, l int) *char
cfn strcmp(a *char, b *char) int
cfn strlen(a *char) int

type MemoryArena struct {
  buffer *char
  len int
  cap int
}

type Program struct {
  arena MemoryArena
  modules *Module.Module 
}

fn new(buffer *char, cap int) Program {
  p Program
  p.arena.buffer = buffer;
  p.arena.len = 0;
  p.arena.cap = cap;
  p.modules = null;
  return p;
}

fn alloc(p *Program, size int) *char {
  if (p.arena.len + size >= p.arena.cap)
    ASSERT(false)//FATALX("Out of memory");
  c *int = &p->arena.len
  d *char = &p->arena.buffer[p->arena.len]
  p->arena.len += size;
  return d;
}

fn copy_string(p *Program, s *char, l int) *char {
  id *char = p.alloc(l + 1);
  strncpy(id, s, l);
  id[l] = '\0';
  return id;
}


fn find_module(p *Program, path *char) *Module.Module  {
  for (m *Module.Module = p->modules; m; m = m->next)
    if (strcmp(m->path, path) == 0)
      return m;
  return null;
}

fn reset_module_finished(p* Program) {
  for (m *Module.Module = p->modules; m; m = m->next)
    m->finished = false;
}

fn add_module(p *Program, pathc *char) *Module.Module {
  size int = strlen(pathc);
  path *char = p.copy_string(pathc, size);
  cname *char = p.copy_string(pathc, size + 1);
  for (c *char = cname; *c; ++c)
    if (*c == '.')
      *c = '_';
  cname[size - 1] = '_';
  cname[size] = '\0';
  m *Module.Module = p.alloc(sizeof(Module.Module)) as *Module.Module
  m->path = path;
  m->c_name = cname;
  m->types = null;
  m->next = p->modules;
  p->modules = m;
  return m;
}