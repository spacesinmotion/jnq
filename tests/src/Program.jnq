
use Module
use Type
use State

cfn strncpy(d *char, s *char, l int) *char
cfn strcmp(a *char, b *char) int
cfn strlen(a *char) int

type MemoryArena struct {
  buffer *char
  len int
  cap int
}

type Program struct {
  arena MemoryArena
  modules *Module.Module 
}

fn new(buffer *char, cap int) Program {
  p Program
  p.arena.buffer = buffer;
  p.arena.len = 0;
  p.arena.cap = cap;
  p.modules = null;
  return p;
}

fn alloc(p *Program, size int) *char {
  if (p.arena.len + size >= p.arena.cap)
    ASSERT(false)//FATALX("Out of memory");
  c *int = &p->arena.len
  d *char = &p->arena.buffer[p->arena.len]
  p->arena.len += size;
  return d;
}

fn copy_string(p *Program, s *char, l int) *char {
  id *char = p.alloc(l + 1);
  strncpy(id, s, l);
  id[l] = '\0';
  return id;
}


fn find_module(p *Program, path *char) *Module.Module  {
  for (m *Module.Module = p->modules; m; m = m->next)
    if (strcmp(m->path, path) == 0)
      return m;
  return null;
}

fn reset_module_finished(p* Program) {
  for (m *Module.Module = p->modules; m; m = m->next)
    m->finished = false;
}

fn add_module(p *Program, pathc *char) *Module.Module {
  size int = strlen(pathc);
  path *char = p.copy_string(pathc, size);
  cname *char = p.copy_string(pathc, size + 1);
  for (c *char = cname; *c; ++c)
    if (*c == '.')
      *c = '_';
  cname[size - 1] = '_';
  cname[size] = '\0';
  m *Module.Module = p.alloc(sizeof(Module.Module)) as *Module.Module
  m->path = path;
  m->c_name = cname;
  m->types = null;
  m->next = p->modules;
  p->modules = m;
  return m;
}

fn new_variable(p *Program, l *State.State, next *Type.Variable) *Type.Variable {
  v *Type.Variable = p.alloc(sizeof(Type.Variable)) as *Type.Variable
  v->next = next;
  v->location = *l;
  return v;
}


fn add_type(p *Program, k Type.TypeKind, name *char, m *Module.Module) *Type.Type {
  tt *Type.Type = m.find_type(name, &name[strlen(name)])
  if (tt != null && tt->kind != Type.TypeKind.PlaceHolder)
    ASSERT(false) // FATALX("Type '%s' allready defined!", name);
  was_placeholder bool = tt != null && tt->kind == Type.TypeKind.PlaceHolder;
  if (!tt)
    tt = p.alloc(sizeof(Type.Type)) as *Type.Type;

  tt->name = name;
  tt->kind = k;
  switch (k) {
  case Type.TypeKind.ModuleT:
    tt->select.moduleT = null;

  case Type.TypeKind.StructT:
    tt->select.structT = p.alloc(sizeof(Type.Struct)) as *Type.Struct
    tt->select.structT->member = null;
    tt->select.structT->module = m;

  case Type.TypeKind.UnionT:
    tt->select.structT = p.alloc(sizeof(Type.Struct)) as *Type.Struct
    tt->select.structT->member = null;
    tt->select.structT->module = m;

  case Type.TypeKind.EnumT:
    tt->select.enumT = p.alloc(sizeof(Type.Enum)) as *Type.Enum
    tt->select.enumT->entries = null;
    tt->select.enumT->module = m;

  case Type.TypeKind.UnionTypeT:
    tt->select.unionT = p.alloc(sizeof(Type.UnionType)) as *Type.UnionType
    tt->select.unionT->member = null;
    tt->select.unionT->module = m;

  case Type.TypeKind.FnT:
    tt->select.fnT = p.alloc(sizeof(Type.Function)) as *Type.Function
    tt->select.fnT->body = null;
    tt->select.fnT->is_extern_c = false;
    tt->select.fnT->module = m;

  case Type.TypeKind.PlaceHolder:
    break;

  case Type.TypeKind.ArrayT:
    tt->select.array_count = 0;
    ASSERT(false) //FATALX("Only base types are implemented to add types");

  case Type.TypeKind.PointerT:
    ASSERT(false) //FATALX("Only base types are implemented to add types");

  }
  if (was_placeholder) {
    if (m->types->_type == tt)
      return tt;
    for (tl *Module.TypeList = m->types; tl->next; tl = tl->next) {
      if (tl->next->_type == tt) {
        tlt *Module.TypeList  = tl->next;
        tl->next = tlt->next;
        tlt->next = m->types;
        m->types = tlt;
        return tt;
      }
    }
    ASSERT(false) //FATALX("did not find place holder type '%s'", tt->name);
    return tt;
  }

  tl *Module.TypeList  = p.alloc(sizeof(Module.TypeList)) as *Module.TypeList
  tl->_type = tt;
  tl->next = m->types;
  m->types = tl;
  return tt;
}