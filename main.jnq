
// use Game from tests.game.Game
// use Program from tests.src.Program
// use tests.game.math.util

// use * from C.stdio

type Object interface {
  fn destroy(o *Object, g *Game)
}

type Object2 interface {
  fn destroy(o *Object2, g *Game)
}

type Game struct {
  objectA vec[8]Object
  objectB vec[8]Object2
}

fn GameObject_recursive_declaration()
{
  printf(" .GameObject_recursive_declaration\n")

  g := Game{}
}

use Some1, SomeAble, some from tests.interfaces

fn main() int
{
  printf("main\n")

  s := SomeAble{}
  ASSERT(s == null)
  s = &Some1{3}
  ASSERT(s != null)
  s = null
  ASSERT(s == null)

  vx := SomeAble{}
  v := vec[]SomeAble{}
  s1 := Some1{2}
  s2 := Some1{2}
  v.push(&s1)
  v.push(&s2)

  some(&v[0])

  printf("ok\n")
  return 0
}
